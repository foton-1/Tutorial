// --Приклади з конспекту--

// --1- Цикл for можна використовувати для ітерації по масиву, тобто «перебрати» його поелементно.
// const clients = ["Mango", "Ajax", "Poly"];
// for (let i = 0; i < clients.length; i += 1) {
//   console.log(i, clients[i]);
// }

// --2- Конструкція for...of оголошує цикл, що перебирає ітерабельні об'єкти, як-от масиви і рядки.
// -Тіло циклу буде виконуватися для значення кожного елемента.
// -Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації.
// -for (const variable of iterable) { //тіло циклу }
// const clients = ["Mango", "Ajax", "Poly"];
// for (const client of clients) {
//   console.log(client);
// }

/* --3- Оператори break і continue--
 -На кожній ітерації будемо перевіряти чи збігається елемент масиву з
 -іменем клієнта. Якщо збігається - записуємо в message повідомлення
 -про успіх і робимо break, щоб далі не шукати
 -Якщо вони не збігаються - записуємо в message повідомлення про відсутність імені*/
// const clients = ["Mango", "Poly", "Ajax"];
// const clientNameToFind = "Poly";
// let message;
// for (const client of clients) {
//   if (client === clientNameToFind) {
//     message = "Клієнт з таким ім'ям є в базі даних!";
//     break;
//   }
//   message = "Клієнт з таким ім'ям відсутній в базі даних!";
// }
// console.log(message);

/* -continue-
 -Для чисел, менших ніж порогове значення, спрацьовує continue, виконання тіла
 -припиняється і управління передається на наступну ітерацію.*/
// const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34];
// const threshold = 15;
// for (let i = 0; i < numbers.length; i += 1) {
//   if (numbers[i] < threshold) {
//     continue;
//   }
//   console.log(`Число більше за ${threshold}: ${numbers[i]}`); // 18, 29, 34
// }

/* --Присвоєння за посиланням і за значенням--
 -Присвоєння за значенням, в пам'яті буде створена ще
 -одна комірка, в яку буде скопійоване значення 5
 -Змінимо значення a
 -Значення b не змінилося, оскільки це окрема копія*/
// let a = 5;
// let b = a;
// console.log(a); // 5
// console.log(b); // 5
// a = 10;
// console.log(a); // 10
// console.log(b); // 5

/*-Складні типи - об'єкти, масиви, функції присвоюються за посиланням,
 -тобто змінна просто отримує посилання на вже існуючий об'єкт.
 -Оскільки a - це масив, в b записується посилання на вже існуючий
 -масив в пам'яті. Тепер a і b вказують на той самий масив.
 -Змінимо масив, додавши ще один елемент, використовуючи вказівник з a
 -b також змінилось, тому що b, як і a,
 -просто містить посилання на те ж саме місце в пам'яті
 -Результат повторюється--*/
// const a = ["Mango"];
// const b = a;
// console.log(a); // ["Mango"]
// console.log(b); // ["Mango"]
// a.push("Poly");
// console.log(a); // ["Mango", "Poly"]
// console.log(b); // ["Mango", "Poly"]
// b.push("Ajax");
// console.log(a); // ["Mango", "Poly", "Ajax"]
// console.log(b); // ["Mango", "Poly", "Ajax"]
